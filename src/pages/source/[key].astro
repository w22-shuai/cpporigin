---
// ==========================================
// 文件路径: src/pages/index.astro
// ==========================================

import type { D1Database } from '@cloudflare/workers-types';

// 1. 初始化环境与变量
const runtime = Astro.locals.runtime;
let db: D1Database | null = null;
let errorMsg = "";
let dataList: any[] = [];
let totalCount = 0;

// 2. 连接 D1 数据库
if (runtime && runtime.env) {
    if (runtime.env.cpporigin) {
        db = runtime.env.cpporigin as D1Database;
    }
}

// 3. 处理分页参数
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const pageSize = 10;
const offset = (page - 1) * pageSize;

// 4. 执行查询
if (db) {
    try {
        const result = await db.prepare(
            "SELECT * FROM cpporigin ORDER BY key DESC LIMIT ? OFFSET ?"
        ).bind(pageSize, offset).all();
        dataList = result.results;
        const countRes = await db.prepare("SELECT COUNT(*) as count FROM cpporigin").first();
        totalCount = countRes?.count as number || 0;
    } catch (e: any) {
        errorMsg = "数据库查询出错: " + e.message;
    }
} else {
    if (!runtime) {
        errorMsg = "本地预览模式：未检测到 Cloudflare Runtime";
    } else {
        errorMsg = "错误：找不到名为 'cpporigin' 的数据库绑定";
    }
}

const totalPages = Math.ceil(totalCount / pageSize);
const hasPrev = page > 1;
const hasNext = page < totalPages;

function formatTime(val: any) {
    if (!val) return '-';
    if (typeof val === 'number') return new Date(val * 1000).toISOString().split('T')[0];
    return val;
}
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coastline Data View</title>
    <style>
        /* ================= 基础重置 ================= */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* 禁止Body滚动 */
            background-color: #000;
            color: #fff;
        }

        /* ================= WebGL 背景 ================= */
        #gl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* ================= 内容容器 (更通透的玻璃拟态) ================= */
        .glass-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .content-card {
            /* 背景变得更黑更透明，为了衬托后面的亮光 */
            background: rgba(0, 20, 40, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 20px;
            padding: 50px; /* 篇幅拉大 */
            width: 100%;
            max-width: 1100px; /* 宽度拉大 */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15);
            margin-bottom: 40px;
        }

        /* ================= 标题与排版 ================= */
        h1 {
            font-size: 3.5rem; /* 大字体 */
            font-weight: 900;
            text-align: center;
            margin-bottom: 40px;
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255, 200, 100, 0.6); /* 金色光晕 */
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .error-box {
            background: rgba(255, 80, 80, 0.4);
            color: #xffd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid rgba(255,0,0,0.3);
        }

        /* ================= 表格样式 ================= */
        .data-table-wrapper {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 10px; /* 行间距 */
            font-size: 1.2rem;
        }
        th {
            padding: 20px;
            text-align: left;
            color: #ffd700; /* 金色表头 */
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        td {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05); /* 每行微弱背景 */
            color: #eee;
            border-top: 1px solid rgba(255,255,255,0.05);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        td:first-child { border-top-left-radius: 10px; border-bottom-left-radius: 10px; border-left: 1px solid rgba(255,255,255,0.05);}
        td:last-child { border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-right: 1px solid rgba(255,255,255,0.05);}

        tr:hover td {
            background-color: rgba(255, 215, 0, 0.15); /* 金色悬停 */
            transform: scale(1.01);
            transition: all 0.2s ease;
        }

        /* ================= 分页按钮 ================= */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 50px;
        }
        .btn {
            text-decoration: none;
            padding: 15px 40px;
            border-radius: 50px;
            /* 金色夕阳渐变 */
            background: linear-gradient(135deg, #FF9900 0%, #FF5500 100%);
            color: white;
            font-weight: bold;
            font-size: 1.3rem;
            box-shadow: 0 4px 25px rgba(255, 100, 0, 0.4);
            transition: all 0.3s;
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px rgba(255, 120, 0, 0.6);
            filter: brightness(1.2);
        }
        .btn.disabled {
            background: #555;
            pointer-events: none;
            box-shadow: none;
            opacity: 0.5;
        }
        .page-info {
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<!-- WebGL 画布 -->
<canvas id="gl-canvas"></canvas>

<!-- 内容区域 -->
<div class="glass-container">
    <div class="content-card">
        <h1>Coastline Database</h1>

        {errorMsg && <div class="error-box">{errorMsg}</div>}

        <div class="data-table-wrapper">
            {dataList.length === 0 && !errorMsg ? (
                    <p style="text-align:center; padding: 30px; font-size: 1.2rem;">暂无数据</p>
            ) : (
                    <table>
                        <thead>
                        <tr>
                            <th>Key</th>
                            <th>Value</th>
                            <th>Time</th>
                        </tr>
                        </thead>
                        <tbody>
                        {dataList.map((item) => (
                                <tr>
                                    <td style="font-family: monospace; font-size: 1.3rem;">{item.key}</td>
                                    <td>{item.val || item.value}</td>
                                    <td>{formatTime(item.created_at)}</td>
                                </tr>
                        ))}
                        </tbody>
                    </table>
            )}
        </div>

        <div class="pagination">
            <a href={`?page=${page - 1}`} class={`btn ${!hasPrev ? 'disabled' : ''}`}>← Prev</a>
            <span class="page-info">{page} / {totalPages || 1}</span>
            <a href={`?page=${page + 1}`} class={`btn ${!hasNext ? 'disabled' : ''}`}>Next →</a>
        </div>
    </div>
</div>

<!-- WebGL 源码：阳光海岸特效 -->
<script is:inline>
    const canvas = document.getElementById('gl-canvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
        console.error("WebGL not supported");
    }

    // ============ 配置区域 ============
    // 注意：请替换此URL为你上传的图片，或者放在 public/bg.jpg
    // 这里使用 Unsplash 类似的海岸图作为演示
    const imgUrl = "/preview.jpg";
    // =================================

    // 顶点着色器
    const vsSource = `
            attribute vec4 position;
            varying vec2 vUv;
            void main() {
                gl_Position = position;
                // 将坐标 [-1, 1] 映射到 UV [0, 1]
                vUv = position.xy * 0.5 + 0.5;
                // WebGL 纹理坐标系 Y 轴通常是翻转的，视图片情况调整
                vUv.y = 1.0 - vUv.y; 
            }
        `;

    // 片元着色器 (核心特效)
    const fsSource = `
            precision mediump float;
            uniform sampler2D u_image;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_imgRes; // 图片原始分辨率
            varying vec2 vUv;

            // 模拟 CSS "background-size: cover"
            vec2 getCoverUv(vec2 uv, vec2 resolution, vec2 texRes) {
                float screenRatio = resolution.x / resolution.y;
                float texRatio = texRes.x / texRes.y;
                
                vec2 newUv = uv;
                
                if (screenRatio > texRatio) {
                    // 屏幕更宽，按宽适配，裁剪高度
                    float scale = screenRatio / texRatio;
                    newUv.y = (uv.y - 0.5) * scale + 0.5;
                } else {
                    // 屏幕更高，按高适配，裁剪宽度
                    float scale = texRatio / screenRatio;
                    newUv.x = (uv.x - 0.5) * scale + 0.5;
                }
                return newUv;
            }

            void main() {
                // 1. 获取正确的 UV (Cover 模式)
                vec2 uv = getCoverUv(vUv, u_resolution, u_imgRes);
                
                // 2. 采样原始颜色
                vec4 texColor = texture2D(u_image, uv);
                
                // 3. 计算亮度 (Luminance)
                float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));

                // 4. 创建闪烁遮罩 (只在高亮区域闪烁，例如阳光和水面反光)
                // smoothstep(0.6, 1.0, brightness) 意味着只有亮度大于0.6的像素才会开始闪烁
                float shineMask = smoothstep(0.55, 1.0, brightness);

                // 5. 生成动态闪烁波形
                // 使用正弦波叠加，制造随机感的呼吸/闪烁效果
                float shimmer = sin(u_time * 2.0 + uv.x * 10.0) + sin(u_time * 1.5 + uv.y * 5.0);
                shimmer = shimmer * 0.2 + 0.8; // 归一化强度

                // 6. 添加"神光" (God Rays) 泛光效果 (简单的径向增强)
                // 假设光源在左上角或中间偏上
                float sunGlow = 0.0;
                // 如果是那张悬崖图，光源大约在 uv(0.4, 0.3) 附近（需根据实际图片调整，这里做个通用的动态光）
                // 我们让高光部分根据时间稍微过曝一点
                vec3 glowColor = vec3(1.0, 0.9, 0.6); // 金黄色阳光

                // 7. 混合最终颜色
                // 原始颜色 + (光色 * 遮罩 * 闪烁系数)
                vec3 finalColor = texColor.rgb + (glowColor * shineMask * shimmer * 0.3);

                // 也可以稍微增加一点对比度让悬崖更深邃
                finalColor = pow(finalColor, vec3(1.1)); 

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    // Buffer setup
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, 1, 1, 1, -1, -1, 1, -1
    ]), gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const uTimeLoc = gl.getUniformLocation(program, "u_time");
    const uResLoc = gl.getUniformLocation(program, "u_resolution");
    const uImgResLoc = gl.getUniformLocation(program, "u_imgRes");
    const uImageLoc = gl.getUniformLocation(program, "u_image");

    // Texture Loading
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // 预设一个 1x1 像素防止加载前黑屏
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

    const image = new Image();
    image.crossOrigin = "anonymous"; // 允许跨域加载
    image.src = imgUrl;
    image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // 设置纹理参数
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        // 开始渲染
        requestAnimationFrame(render);
    };

    function render(time) {
        time *= 0.001;

        // Resize handling
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        gl.useProgram(program);

        gl.uniform1f(uTimeLoc, time);
        gl.uniform2f(uResLoc, canvas.width, canvas.height);
        // 传入图片原始尺寸，用于计算 cover 裁剪
        gl.uniform2f(uImgResLoc, image.width || 1, image.height || 1);
        gl.uniform1i(uImageLoc, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }
</script>
</body>
</html>