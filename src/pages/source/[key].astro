---
// ==========================================
// æ–‡ä»¶è·¯å¾„: src/pages/index.astro
// ==========================================

import type { D1Database } from '@cloudflare/workers-types';

// 1. åˆå§‹åŒ–ç¯å¢ƒä¸å˜é‡
const runtime = Astro.locals.runtime;
let db: D1Database | null = null;
let errorMsg = "";
let dataList: any[] = [];
let totalCount = 0;

// 2. è¿æ¥ D1 æ•°æ®åº“
if (runtime && runtime.env) {
    if (runtime.env.cpporigin) {
        db = runtime.env.cpporigin as D1Database;
    }
}

// 3. å¤„ç†åˆ†é¡µå‚æ•°
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const pageSize = 10;
const offset = (page - 1) * pageSize;

// 4. æ‰§è¡ŒæŸ¥è¯¢
if (db) {
    try {
        // æŸ¥è¯¢åˆ—è¡¨ (æŒ‰ key å€’åºï¼Œæˆ–è€…æŒ‰ id å€’åº)
        const result = await db.prepare(
            "SELECT * FROM cpporigin ORDER BY key DESC LIMIT ? OFFSET ?"
        ).bind(pageSize, offset).all();

        dataList = result.results;

        // æŸ¥è¯¢æ€»æ•°
        const countRes = await db.prepare("SELECT COUNT(*) as count FROM cpporigin").first();
        totalCount = countRes?.count as number || 0;

    } catch (e: any) {
        errorMsg = "æ•°æ®åº“æŸ¥è¯¢å‡ºé”™: " + e.message;
    }
} else {
    if (!runtime) {
        errorMsg = "æœ¬åœ°é¢„è§ˆæ¨¡å¼ï¼šæœªæ£€æµ‹åˆ° Cloudflare Runtime (è¯·éƒ¨ç½²åæµ‹è¯•)";
    } else {
        errorMsg = "é”™è¯¯ï¼šæ‰¾ä¸åˆ°åä¸º 'cpporigin' çš„æ•°æ®åº“ç»‘å®š";
    }
}

// 5. è®¡ç®—åˆ†é¡µé€»è¾‘
const totalPages = Math.ceil(totalCount / pageSize);
const hasPrev = page > 1;
const hasNext = page < totalPages;

// 6. è¾…åŠ©å‡½æ•°ï¼šæ—¶é—´æ ¼å¼åŒ–
function formatTime(val: any) {
    if (!val) return '-';
    if (typeof val === 'number') return new Date(val * 1000).toISOString().split('T')[0];
    return val;
}
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Data View</title>
    <style>
        /* ================= åŸºç¡€é‡ç½® ================= */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* æ ¸å¿ƒï¼šç¦æ­¢ Body æ»šåŠ¨ï¼Œç”±å†…éƒ¨å®¹å™¨æ¥ç®¡ï¼ŒèƒŒæ™¯é”æ­» */
            background-color: #006994; /* å…œåº•é¢œè‰² */
            color: #1a2c38;
        }

        /* ================= WebGL èƒŒæ™¯ ================= */
        #gl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* æ”¾åœ¨æœ€åº•å±‚ */
        }

        /* ================= å†…å®¹å®¹å™¨ (ç»ç’ƒæ‹Ÿæ€) ================= */
        .glass-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            overflow-y: auto; /* å†…å®¹æº¢å‡ºæ—¶ï¼Œä»…å®¹å™¨å†…éƒ¨æ»šåŠ¨ï¼ŒèƒŒæ™¯ä¸åŠ¨ */
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .content-card {
            background: rgba(255, 255, 255, 0.65); /* äº®è‰²åŠé€æ˜ */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 1000px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.4);
            margin-bottom: 40px;
        }

        /* ================= æ ‡é¢˜ä¸æ’ç‰ˆ ================= */
        h1 {
            font-size: 3rem; /* ç¯‡å¹…æ‹‰å¤§ï¼šå¤§æ ‡é¢˜ */
            font-weight: 800;
            text-align: center;
            margin-bottom: 30px;
            color: #004e6e;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8);
            letter-spacing: 2px;
        }

        .error-box {
            background: rgba(255, 80, 80, 0.2);
            color: #8a0000;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }

        /* ================= è¡¨æ ¼æ ·å¼ ================= */
        .data-table-wrapper {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1.1rem;
        }
        th, td {
            padding: 16px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 78, 110, 0.1);
        }
        th {
            background-color: rgba(0, 119, 182, 0.1);
            color: #003f5c;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        tr:hover td {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* ================= åˆ†é¡µæŒ‰é’® ================= */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 40px;
        }
        .btn {
            text-decoration: none;
            padding: 12px 30px;
            border-radius: 30px;
            background: linear-gradient(135deg, #48cae4 0%, #0077b6 100%);
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 119, 182, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 119, 182, 0.5);
        }
        .btn.disabled {
            background: #ccc;
            pointer-events: none;
            box-shadow: none;
        }
        .page-info {
            font-size: 1.1rem;
            font-weight: bold;
            color: #005f73;
        }
    </style>
</head>
<body>

<!-- WebGL ç”»å¸ƒï¼šå…¨å±èƒŒæ™¯ -->
<canvas id="gl-canvas"></canvas>

<!-- å†…å®¹åŒºåŸŸ -->
<div class="glass-container">
    <div class="content-card">
        <h1>ğŸŒŠ OCEAN DATABASE</h1>

        {errorMsg && <div class="error-box">{errorMsg}</div>}

        <div class="data-table-wrapper">
            {dataList.length === 0 && !errorMsg ? (
                    <p style="text-align:center; padding: 20px;">æš‚æ— æ•°æ®</p>
            ) : (
                    <table>
                        <thead>
                        <tr>
                            <th>Key</th>
                            <th>Value</th>
                            <th>Created At</th>
                        </tr>
                        </thead>
                        <tbody>
                        {dataList.map((item) => (
                                <tr>
                                    <td><strong>{item.key}</strong></td>
                                    <td>{item.val || item.value}</td>
                                    <td>{formatTime(item.created_at)}</td>
                                </tr>
                        ))}
                        </tbody>
                    </table>
            )}
        </div>

        <!-- åˆ†é¡µ -->
        <div class="pagination">
            <a href={`?page=${page - 1}`} class={`btn ${!hasPrev ? 'disabled' : ''}`}>â† Prev</a>
            <span class="page-info">Page {page} of {totalPages || 1}</span>
            <a href={`?page=${page + 1}`} class={`btn ${!hasNext ? 'disabled' : ''}`}>Next â†’</a>
        </div>
    </div>
</div>

<!-- WebGL æ ¸å¿ƒæºç  -->
<script is:inline>
    const canvas = document.getElementById('gl-canvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
        console.error("WebGL not supported");
    }

    // é¡¶ç‚¹ç€è‰²å™¨ (Vertex Shader) - ç®€å•çš„å…¨å±è¦†ç›–
    const vsSource = `
            attribute vec4 position;
            void main() {
                gl_Position = position;
            }
        `;

    // ç‰‡å…ƒç€è‰²å™¨ (Fragment Shader) - æµ·æ´‹ä¸æ°”æ³¡é€»è¾‘
    const fsSource = `
            precision mediump float;
            uniform float u_time;
            uniform vec2 u_resolution;

            // ä¼ªéšæœºå‡½æ•°
            float random (in vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            // æ°”æ³¡ç»˜åˆ¶å‡½æ•°
            float bubble(vec2 uv, float scale, float speed, float phase) {
                // å‘ä¸Šç§»åŠ¨
                float t = u_time * speed;
                uv.y += t;
                
                // å·¦å³æ‘‡æ‘†
                uv.x += sin(t * 1.5 + phase) * 0.05;

                // ç½‘æ ¼åŒ–ä»¥ç”Ÿæˆå¤šä¸ªæ°”æ³¡
                vec2 grid = fract(uv * scale) - 0.5;
                vec2 id = floor(uv * scale);

                // æ ¹æ®ç½‘æ ¼IDå¼•å…¥éšæœºæ€§
                float rnd = random(id);
                
                // ä»…åœ¨éƒ¨åˆ†ç½‘æ ¼ä¸­ç”Ÿæˆæ°”æ³¡ï¼Œå¢åŠ ç¨€ç–æ„Ÿ
                if (rnd > 0.3) return 0.0; 

                float size = 0.1 + rnd * 0.2; // éšæœºå¤§å°
                float dist = length(grid);
                
                // æ°”æ³¡è¾¹ç¼˜å…‰åœˆ (äº®è‰²)
                float alpha = smoothstep(size, size - 0.02, dist);
                
                // æ°”æ³¡é«˜å…‰
                float highlight = smoothstep(size * 0.3, size * 0.1, length(grid - vec2(0.05, 0.05)));
                
                return alpha * 0.4 + highlight * 0.8;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                
                // 1. èƒŒæ™¯æ¸å˜ (äº®è‰²æµ·æ´‹ï¼šæµ…é’ -> æ·±è“)
                vec3 colTop = vec3(0.0, 0.85, 0.95); // é¡¶éƒ¨æµ…è‰²
                vec3 colBot = vec3(0.0, 0.4, 0.7);   // åº•éƒ¨æ·±è‰²
                vec3 bg = mix(colBot, colTop, uv.y * 1.2);

                // 2. æ°´å…‰æ³¢çº¹ (ç®€å•çš„æ­£å¼¦æ³¢å åŠ )
                float waves = sin(uv.x * 10.0 + u_time) * 0.01 + sin(uv.y * 8.0 - u_time * 0.5) * 0.01;
                bg += waves * 0.1;

                // 3. æ°”æ³¡å±‚ (å¤šå±‚å åŠ ï¼Œäº§ç”Ÿæ™¯æ·±æ„Ÿ)
                float bubbles = 0.0;
                bubbles += bubble(uv, 4.0, 0.1, 0.0);   // å¤§æ°”æ³¡ï¼Œæ…¢
                bubbles += bubble(uv, 8.0, 0.2, 2.0);   // ä¸­æ°”æ³¡
                bubbles += bubble(uv, 16.0, 0.35, 4.0); // å°æ°”æ³¡ï¼Œå¿«

                // æ··åˆé¢œè‰²ï¼Œæ°”æ³¡ä¸ºäº®ç™½è‰²
                vec3 finalColor = bg + vec3(1.0) * bubbles;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

    // ç¼–è¯‘ç€è‰²å™¨å·¥å…·å‡½æ•°
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    // åˆ›å»ºç¨‹åº
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }

    // è®¾ç½®å…¨å±å››è¾¹å½¢
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
        -1.0,  1.0,
        1.0,  1.0,
        -1.0, -1.0,
        1.0, -1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.useProgram(program);

    const uTimeLoc = gl.getUniformLocation(program, "u_time");
    const uResLoc = gl.getUniformLocation(program, "u_resolution");

    // æ¸²æŸ“å¾ªç¯
    function render(time) {
        time *= 0.001; // ç§’

        // é€‚é…å±å¹•å°ºå¯¸
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        gl.uniform2f(uResLoc, canvas.width, canvas.height);
        gl.uniform1f(uTimeLoc, time);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>